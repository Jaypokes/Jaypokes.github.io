<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var photos = ["https://i.imgur.com/0akFeLP.jpeg","https://i.imgur.com/0akFeLP.jpeg","https://i.imgur.com/GTmWDGJ.jpg"];
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var url = "https://code.jquery.com/pep/0.4.3/pep.js";
        var s = document.createElement("script");
        s.src = url;
        document.head.appendChild(s);

        var createScene = async function() {
            var scene = new BABYLON.Scene(engine);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 2, 10, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
        
            camera.inputs.attached.mousewheel.detachControl(canvas);
            //To prevent zoom out to a sphere in mobile
            camera.upperRadiusLimit = camera.radius;
            camera.lowerRadiusLimit = camera.radius;
        
            //Create PhotoDome
            var dome = new BABYLON.PhotoDome(
                "testdome",
                "https://i.imgur.com/0akFeLP.jpeg",
                {
                    resolution: 32,
                    size: 1000,
                    useDirectMapping: false
                },
                scene
            );
            dome.imageMode = BABYLON.PhotoDome.MODE_MONOSCOPIC;
            dome.fovMultiplier = 2.0;
            dome.isPickable = false;
        
        function createOrb(length,index,url){

            // Create sphere shaped holders
            var _sphereDiameter = 2.0;
            var _sphereDiameterX = 2.0;
            
            sphere = BABYLON.MeshBuilder.CreateSphere("imgSphere"+index, { diameter: _sphereDiameter, diameterX: _sphereDiameterX }, scene);;
            sphere.position.y = 0;
            if(length%2==0)
                sphere.position.x = -((((length/2)-index)*3)-1.5);
            else
                sphere.position.x = -(((length/2)-.5)-index)*3;
            sphere.position.z = 0.5;
        
            var _material = new BABYLON.StandardMaterial("sphere material", scene);
            var _texture = new BABYLON.Texture(url, scene);
            _texture.vScale = -1;
            _material.ambientTexture = _texture;
            _material.emissiveColor = new BABYLON.Color3(1, 1, 1);
        
            sphere.material = _material;
            sphere.isPickable = true;
            return sphere;
        
        }
        const spheres = new Array();
        const urls = ["https://i.imgur.com/GTmWDGJ.jpg","https://playground.babylonjs.com/textures/360photo.jpg","https://playground.babylonjs.com/textures/360photo.jpg","https://playground.babylonjs.com/textures/360photo.jpg","https://i.imgur.com/0akFeLP.jpeg"]
        for(let i = 0;i<urls.length;i++){
            spheres.push(createOrb(urls.length,i,urls[i]));
        }

        // sphere1 = createOrb(5,0,"https://playground.babylonjs.com/textures/360photo.jpg");
        // sphere2 = createOrb(5,1,"https://i.imgur.com/GTmWDGJ.jpg");
        // createOrb(5,2,"https://i.imgur.com/0akFeLP.jpeg");
        // createOrb(5,3,"https://i.imgur.com/0akFeLP.jpeg");
        // createOrb(5,4,"https://i.imgur.com/0akFeLP.jpeg");
        
          
        
            //Initialize WebXR
            var xrHelper;
            try {
                xrHelper = await scene.createDefaultXRExperienceAsync();
            } catch(ex){
                alert("WebXR not supported");
            }
            
            scene.activeCamera.setTarget(new BABYLON.Vector3(0, 0, 0));
            // Runs every frame to rotate the sphere
            scene.onBeforeRenderObservable.add(() => {
                // for(let i = 0;i<=spheres.length;i++){
                //     console.log(spheres.length);
                //     spheres[i].rotation.y += 0.0002 * scene.getEngine().getDeltaTime();
                // }
                // sphere2.rotation.y += 0.0002 * scene.getEngine().getDeltaTime();
            });
        
            //sphere.actionManager = new BABYLON.ActionManager(scene);
        
            //sphere.actionManager.registerAction(
            //    new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
            //    function(event){
            //        var pickedMesh = event.meshUnderPointer; 
            //  dome.photoTexture = new BABYLON.Texture("img2.jpg", scene, false ,false);            
            //    })
            //);
        
            var _prevPickedMesh = "";
            scene.onPointerObservable.add((pointerInfo) => {
                console.log(_prevPickedMesh);
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        var pickResult = pointerInfo.pickInfo;
                        if (pickResult.hit) {
                            var pickedMesh = pickResult.pickedMesh;
                            
                            if (pickedMesh.name == "testdome_mesh") return;
                            if (_prevPickedMesh == pickedMesh.name) return;
                            _prevPickedMesh = pickedMesh.name;
        
                            if (pickedMesh) {
                                if (typeof pickedMesh.material.ambientTexture !== 'undefined') {
                                    dome.photoTexture = new BABYLON.Texture(pickedMesh.material.ambientTexture.name, scene, false, true);
                                }
        
                            }
                        }
                        break;
                    case BABYLON.PointerEventTypes.POINTERPICK:
                        break;
                }
                
            });
        
            return scene;
        };
                window.initFunction = async function() {
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
                            
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
